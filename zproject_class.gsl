#   Generate project API
#
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details.
#
#   Copyright (c) the Contributors as noted in the AUTHORS file.
#   This file is part of zproject.
#
#   This Source Code Form is subject to the terms of the Mozilla Public
#   License, v. 2.0. If a copy of the MPL was not distributed with this
#   file, You can obtain one at http://mozilla.org/MPL/2.0/.

.macro generate_project_api
.#
.#  Build the project header file
.#
.directory.create ("include")
.project_header_file = "include/$(project.header:)"
.if !file.exists (project_header_file) & count (class, class.name = project.name) = 0
.   output project_header_file
/*  =========================================================================
    $(project.name) - $(project.description?'':)

.   for project.license
    $(string.trim (license.):block                                         )
.   endfor
    =========================================================================
*/

#ifndef $(PROJECT.NAME:c)_H_INCLUDED
#define $(PROJECT.NAME:c)_H_INCLUDED

//  Include the project library file
#include "$(project.prefix)_library.h"

//  Add your own public definitions here, if you need them

#endif
.endif
.output "include/$(project.prefix)_library.h"
/*  =========================================================================
    $(project.name) - $(PROJECT.NAME) wrapper

.   for project.license
    $(string.trim (license.):block                                         )
.   endfor

$(project.GENERATED_WARNING_HEADER:)
    =========================================================================
*/

#ifndef $(PROJECT.PREFIX:C)_LIBRARY_H_INCLUDED
#define $(PROJECT.PREFIX:C)_LIBRARY_H_INCLUDED

//  Set up environment for the application
.if file.exists ("include/$(project.prelude)")
#include "$(project.prelude)"
.endif

//  External dependencies
.for use where !defined (implied)
.    if (use.optional = 1)
#if defined (HAVE_$(USE.LIBNAME))
#include <$(use.header)>
#endif
.    else
#include <$(use.header)>
.    endif
.endfor

//  $(PROJECT.NAME) version macros for compile-time API detection

#define $(PROJECT.NAME:c)_VERSION_MAJOR $(project->version.major)
#define $(PROJECT.NAME:c)_VERSION_MINOR $(project->version.minor)
#define $(PROJECT.NAME:c)_VERSION_PATCH $(project->version.patch)

#define $(PROJECT.NAME:c)_MAKE_VERSION(major, minor, patch) \\
    ((major) * 10000 + (minor) * 100 + (patch))
#define $(PROJECT.NAME:c)_VERSION \\
    $(PROJECT.NAME:c)_MAKE_VERSION($(PROJECT.NAME:c)_VERSION_MAJOR, $(PROJECT.NAME:c)_VERSION_MINOR, $(PROJECT.NAME:c)_VERSION_PATCH)

#if defined (__WINDOWS__)
#   if defined $(PROJECT.LIBNAME:c)_STATIC
#       define $(PROJECT.PREFIX:c)_EXPORT
#   elif defined $(PROJECT.LIBNAME:c)_EXPORTS
#       define $(PROJECT.PREFIX:c)_EXPORT __declspec(dllexport)
#   else
#       define $(PROJECT.PREFIX:c)_EXPORT __declspec(dllimport)
#   endif
#else
#   define $(PROJECT.PREFIX:c)_EXPORT
#endif

//  Opaque class structures to allow forward references
.for project.class where scope = "public" & !is_c_element_draft (class)
.   if !defined (class.api)
.       resolve_c_class(class)
.   endif
typedef struct _$(class.c_name)_t $(class.c_name)_t;
#define $(CLASS.C_NAME)_T_DEFINED
.endfor
.if count (project.class, scope = "public" & is_c_element_draft (class))

//  Draft APIs, excluded by default in stable releases
#ifdef WITH_DRAFTS
.   for project.class where scope = "public" & is_c_element_draft (class)
.       if !defined (class.api)
.           resolve_c_class(class)
.       endif
typedef struct _$(class.c_name)_t $(class.c_name)_t;
#define $(CLASS.C_NAME)_T_DEFINED
.   endfor
#endif // WITH_DRAFTS
.endif
.if count (constant, scope = "public")

//  Public constants
.endif
.for constant where scope = "public" & !is_c_element_draft (constant)
#define $(CONSTANT.NAME)\t$(constant.value) //  $(constant.?'')
.endfor
.if count (constant, scope = "public" & is_c_element_draft (constant))

//  Draft APIs, excluded by default in stable releases
#ifdef WITH_DRAFTS
.   for constant where scope = "public" & is_c_element_draft (constant)
#define $(CONSTANT.NAME)\t$(constant.value) //  $(constant.?'')
.   endfor
#endif // WITH_DRAFTS
.endif

//  Public API classes
.for header where scope = "public"
#include "$(header.name).h"
.endfor
.for class where scope = "public" & class.c_name <> "$(project.name)" & !is_c_element_draft (class)
#include "$(class.c_name).h"
.endfor
.if count (project.class, scope = "public" & is_c_element_draft (class))

//  Draft APIs, excluded by default in stable releases
#ifdef WITH_DRAFTS
.  for class where scope = "public" & class.c_name <> "$(project.name)" & is_c_element_draft (class)
#include "$(class.c_name).h"
.  endfor
#endif // WITH_DRAFTS
.endif

#endif
/*
$(project.GENERATED_WARNING_HEADER:)
*/
.#
.#  Build the project selftest file
.#
.if project.use_cxx
.output "src/$(project.prefix)_selftest.cc"
.else
.output "src/$(project.prefix)_selftest.c"
.endif
/*  =========================================================================
    $(project.prefix)_selftest.c - run selftests

    Runs all selftests.

    -------------------------------------------------------------------------
.   for project.license
    $(string.trim (license.):block                                         )
.   endfor

$(project.GENERATED_WARNING_HEADER:)
    =========================================================================
*/

#include "$(project.prefix)_classes.h"

typedef struct {
    const char *testname;
    void (*test) (bool);
} test_item_t;

static test_item_t
all_tests [] = {
.for class where !is_c_element_draft (class)
    { "$(class.c_name)", $(class.c_name)_test },
.endfor
.if count (class, is_c_element_draft (class))
#ifdef WITH_DRAFTS
.   for class where is_c_element_draft (class)
    { "$(class.c_name)", $(class.c_name)_test },
.   endfor
#endif // WITH_DRAFTS
.endif
    {0, 0}          //  Sentinel
};

//  -------------------------------------------------------------------------
//  Test whether a test is available.
//  Return a pointer to a test_item_t if available, NULL otherwise.
//

test_item_t *
test_available (const char *testname)
{
    test_item_t *item;
    for (item = all_tests; item->test; item++) {
        if (streq (testname, item->testname))
            return item;
    }
    return NULL;
}

//  -------------------------------------------------------------------------
//  Run all tests.
//

static void
test_runall (bool verbose)
{
    test_item_t *item;
    printf ("Running $(project.name) selftests...\\n");
    for (item = all_tests; item->test; item++)
        item->test (verbose);

    printf ("Tests passed OK\\n");
}

int
main (int argc, char **argv)
{
    bool verbose = false;
    test_item_t *test = 0;
    int argn;
    for (argn = 1; argn < argc; argn++) {
        if (streq (argv [argn], "--help")
        ||  streq (argv [argn], "-h")) {
            puts ("$(project.prefix)_selftest.c [options] ...");
            puts ("  --verbose / -v         verbose test output");
            puts ("  --number / -n          report number of tests");
            puts ("  --list / -l            list all tests");
            puts ("  --test / -t [name]     run only test 'name'");
            puts ("  --continue / -c        continue on exception (on Windows)");
            return 0;
        }
        if (streq (argv [argn], "--verbose")
        ||  streq (argv [argn], "-v"))
            verbose = true;
        else
        if (streq (argv [argn], "--number")
        ||  streq (argv [argn], "-n")) {
            puts ("$(count (project.class))");
            return 0;
        }
        else
        if (streq (argv [argn], "--list")
        ||  streq (argv [argn], "-l")) {
            puts ("Available tests:");
.for class
            puts ("    $(class.c_name)");
.endfor
            return 0;
        }
        else
        if (streq (argv [argn], "--test")
        ||  streq (argv [argn], "-t")) {
            argn++;
            if (argn >= argc) {
                fprintf (stderr, "--test needs an argument\\n");
                return 1;
            }
            test = test_available (argv [argn]);
            if (!test) {
                fprintf (stderr, "%s not valid, use --list to show tests\\n", argv [argn]);
                return 1;
            }
        }
        else
        if (streq (argv [argn], "--continue")
        ||  streq (argv [argn], "-c")) {
#ifdef _MSC_VER
            //  When receiving an abort signal, only print to stderr (no dialog)
            _set_abort_behavior (0, _WRITE_ABORT_MSG);
#endif
        }
        else {
            printf ("Unknown option: %s\\n", argv [argn]);
            return 1;
        }
    }
    if (test) {
        printf ("Running $(project.name) test '%s'...\\n", test->testname);
        test->test (verbose);
    }
    else
        test_runall (verbose);

    return 0;
}
/*
$(project.GENERATED_WARNING_HEADER:)
*/
.-
.-  Build the classes header for private header files and constants
.-
.output "src/$(project.prefix)_classes.h"
/*  =========================================================================
    $(project.prefix)_classes - private header file

.   for project.license
    $(string.trim (license.):block                                         )
.   endfor
$(project.GENERATED_WARNING_HEADER:)
    =========================================================================
*/

#ifndef $(PROJECT.PREFIX:c)_CLASSES_H_INCLUDED
#define $(PROJECT.PREFIX:c)_CLASSES_H_INCLUDED

//  Platform definitions, must come first
#include "platform.h"

//  External API
#include "../include/$(project.header:)"

//  Internal API
.for class where scope = "private"
#include "$(class.c_name).h"
.endfor
.for header where scope = "private"
#include "$(header.name).h"
.endfor

.for constant where scope = "private"
.   if first ()
//  Private constants
.   endif
#define $(CONSTANT.NAME)\t$(constant.value) //  $(constant.?'')
.endfor
#endif
.-
.-  Build the header file for a class
.-
.for class
.   if scope = "private"
.       header_file = "src/$(class.c_name).h"
.   else
.       header_file = "include/$(class.c_name).h"
.   endif
.if !defined (class.api)
.   resolve_c_class(class)
.endif
.if !file.exists (header_file)
.   output header_file
/*  =========================================================================
    $(class.c_name) - $(string.trim (class.?''):no,left)

.   for project.license
    $(string.trim (license.):block                                         )
.   endfor
    =========================================================================
*/

#ifndef $(CLASS.C_NAME)_H_INCLUDED
#define $(CLASS.C_NAME)_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

.   if class.c_name = project.name
//  Include the library file with typdefs, public includes and public constants
#include "$(class.c_name)_library.h"

.   endif
.   if class.scope = "private"
typedef struct _$(class.c_name)_t $(class.c_name)_t;
.   endif

//  @interface
//  Create a new $(class.c_name)
$(PROJECT.PREFIX:c)_EXPORT $(class.c_name)_t *
    $(class.c_name)_new (void);

//  Destroy the $(class.c_name)
$(PROJECT.PREFIX:c)_EXPORT void
    $(class.c_name)_destroy ($(class.c_name)_t **self_p);

//  Print properties of object
$(PROJECT.PREFIX:c)_EXPORT void
    $(class.c_name)_print ($(class.c_name)_t *self);

//  Self test of this class
$(PROJECT.PREFIX:c)_EXPORT void
    $(class.c_name)_test (bool verbose);
//  @end

#ifdef __cplusplus
}
#endif

#endif
.close
# If there is an API defined, then the file must be written so we can
# find and rewrite the @interface section
.endif
.-
.-  Build the source file for a class
.-
.if project.use_cxx
.source_file = "src/$(class.c_name).cc"
.else
.source_file = "src/$(class.c_name).c"
.endif
.if !file.exists (source_file)
.   output source_file
/*  =========================================================================
    $(class.c_name) - $(string.trim (class.?''):no,left)

.   for project.license
    $(string.trim (license.):block                                         )
.   endfor
    =========================================================================
*/

/*
@header
    $(class.c_name) - $(string.trim (class.?''):no,left)
@discuss
@end
*/

#include "$(project.prefix)_classes.h"
.if count (project.constructor)

//  Structure of our class

struct _$(class.c_name)_t {
    int filler;     //  TODO: Declare properties
};
.endif
.for class.constructor as method

//  --------------------------------------------------------------------------
//  $(method.description:no,block)

$(c_method_declaration (method, 1):)
{
    $(class.c_name)_t *self = ($(class.c_name)_t *) zmalloc (sizeof ($(class.c_name)_t));
    assert (self);
    //  TODO: Initialize properties
    return self;
}
.endfor
.for class.destructor as method

//  --------------------------------------------------------------------------
//  $(method.description:no,block)

$(c_method_declaration (method, 1):)
{
    assert (self_p);
    if (*self_p) {
        $(class.c_name)_t *self = *self_p;
        //  TODO: Free class properties
        //  Free object itself
        free (self);
        *self_p = NULL;
    }
}
.endfor

.for class.method where !(method.name = "test")

//  --------------------------------------------------------------------------
//  $(method.description:no,block)

$(c_method_declaration (method, 1):)
{
.   if singleton = 0
    assert (self);
.   endif
.   if ->return.type = "boolean"
    return false;
.   elsif ->return.type = "byte" \
    |     ->return.type = "char" \
    |     ->return.type = "number" \
    |     ->return.type = "integer" \
    |     ->return.type = "real"
    return 0;
.   elsif ->return.type = "nothing"
.   else
    return NULL;
.   endif
}

.endfor
.for class.method where method.name = "test"
//  --------------------------------------------------------------------------
//  $(method.description:no,block)

$(c_method_declaration (method, 1):)
{
    printf (" * $(class.c_name): ");

    //  @selftest
.   if count (project.constructor)
    //  Simple create/destroy test
    $(class.c_name)_t *self = $(class.c_name)_new ();
    assert (self);
    $(class.c_name)_destroy (&self);
.   endif
    //  @end

    printf ("OK\\n");
}
.endfor
.endif
.-
.-  Regenerate the @interface for the class if it has an api model
.-
.if defined (class.api)
.template 0

    # Open the header_file for reading
    handle = file.open (header_file, "ra")
    current_loc = "prefix"
    error = # undefined
    HEADER_FILE_PREFIX = "" # All lines preceding the @interface line
    HEADER_FILE_SUFFIX = "" # All lines following the @end line

    # Read each line from the file and pull out the prefix and suffix blocks
    while defined (handle)
        this_line = handle.read (error)? ""

        if defined (error)
            handle.close ()
            handle = # undefined
        elsif current_loc = "prefix"
            if regexp.match ("//\\s*@interface", this_line)
                current_loc = "interface"
            elsif regexp.match ("//\\s*@warning", this_line)
                # ignore the warning line - do not copy it
            else
                HEADER_FILE_PREFIX += this_line
            endif
        elsif current_loc = "interface"
            if regexp.match ("//\\s*@end", this_line)
                current_loc = "suffix"
            endif
        elsif current_loc = "suffix"
            HEADER_FILE_SUFFIX += this_line
        endif
    endwhile
.endtemplate
.# Now output the file with stored prefix, generated interface, and stored suffix
.output header_file
$(HEADER_FILE_PREFIX:)\
//  @warning THE FOLLOWING @INTERFACE BLOCK IS AUTO-GENERATED BY ZPROJECT
//  @warning Please edit the model at "$(class.api)" to make changes.
//  @interface
.   if (class.state = "draft")
//  This is a draft class, and may change without notice. It is disabled in
//  stable builds by default. If you use this in applications, please ask
//  for it to be pushed to stable state. Use --enable-draft-api to enable.
.   elsif (class.state = "stable")
//  This is a stable class, and may not change except for emergencies. It
//  is provided in stable builds.
.   if count (class.method, method.state = "draft")
//  This class has draft methods, which may change over time. They are not
//  in stable releases, by default. Use --enable-draft-api to enable.
.   endif
.   if count (class.method, method.state = "legacy")
//  This class has legacy methods, which will be removed over time. You
//  should not use them, and migrate any code that is still using them.
.   endif
.   elsif (class.state = "legacy")
//  This is a deprecated class, and will be removed over time. It is
//  provided in stable builds to support old applications. You should
//  stop using this class, and migrate any code that is still using it.
.   endif
.for class.constant
.   if first ()

.   endif
.   if (is_c_element_draft (constant))
#ifdef WITH_DRAFTS
.   endif
#define $(CLASS.NAME:c)_$(NAME:c) $(value)  // $(constant.description:no,block)
.   if (is_c_element_draft (constant))
#endif // WITH_DRAFTS
.   endif
.endfor
.-
.for class.enum

.   if (is_c_element_draft (enum))
#ifdef WITH_DRAFTS
.   endif
// $(enum.description:no,block)
typedef enum {
.   for enum.constant
.       if last()
.           post = ""
.       else
.           post = ","
.       endif
    $(CLASS.NAME:c)_$(CONSTANT.NAME:c) = $(value)$(post)    //  $(string.trim (constant.?''):left)
.   endfor
} $(class.name:c)_$(enum.name:c)_t;
.   if (is_c_element_draft (enum))
#endif // WITH_DRAFTS
.   endif
.endfor
.-
.for class.callback_type

.   if (is_c_element_draft (callback_type))
#ifdef WITH_DRAFTS
.   endif
// $(callback_type.description:no,block)
$(c_callback_typedef (callback_type))
.   if (is_c_element_draft (callback_type))
#endif // WITH_DRAFTS
.   endif
.endfor
.-
.for class.constructor as method

//  $(method.description:no,block)
$(c_method_declaration (method):)
.endfor
.-
.for class.destructor as method

//  $(method.description:no,block)
$(c_method_declaration (method):)
.endfor
.-
.for class.actor

//  $(actor.description:no,block)
$(c_actor_declaration (actor):)
.endfor
.-
.for class.method

.   if (is_c_element_draft (method))
#ifdef WITH_DRAFTS
.   endif
//  $(method.description:no,block)
.if method->return.fresh
//  The caller is responsible for destroying the return value when finished with it.
.endif
$(c_method_declaration (method):)
.   if (is_c_element_draft (method))
#endif // WITH_DRAFTS
.   endif
.endfor
//  @end
$(HEADER_FILE_SUFFIX:)\
.endif
.close
.endfor
.endmacro

if count (class)
    generate_project_api ()
endif
