.template 0
#   Generate minimal JNI language bindings.
#   These are not meant to be idiomatic, but to provide a minimal platform
#   of JNI function bindings on which to base idiomatic Java classes.
#
#   This is a code generator built using the iMatix GSL code generation
#   language. See https://github.com/imatix/gsl for details. This script
#   is licensed under MIT/X11.
#
#   Workflow, in bindings/jni directory:
#   > gradle build
#
#   - Compile java files into classes, with gradle (or IDE, maven, etc.)
#   - Run javah on those compiled classes to generate the header files
#   - Build the shared library from those header files

global.namespace ?= switches.namespace? "org.zeromq.$(project.prefix)"
global.name_path ?= switches.name_path? "org/zeromq/$(project.prefix)"
global.topdir ?= switches.topdir? "bindings/jni"

### Generate CMake infrastructure

.macro generate_cmake
.   output "$(topdir)/CMakeLists.txt"
cmake_minimum_required (VERSION 2.8)

project ($(project.prefix)jni CXX)
enable_language (C)

find_package (JNI REQUIRED)
find_library (ZMQ_LIBRARY NAMES zmq libzmq REQUIRED)
find_library ($(PROJECT.PREFIX)_LIBRARY NAMES $(project.prefix) REQUIRED)

include_directories (${JAVA_INCLUDE_PATH} ${JAVA_INCLUDE_PATH2} src/native/include)

set ($(project.prefix)jni_sources
.for project.class where defined (class.api) & class.jni_okay ?= 1
.   my.cname = "$(namespace:c)_$(class.name:pascal)"
    src/main/c/$(my.cname:).c
.endfor
)

add_library ($(project.prefix)jni SHARED ${$(project.prefix)jni_sources})

set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -pedantic -O2")
set (CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)
set (CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)
set (CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/build)

target_link_libraries ($(project.prefix)jni ${ZMQ_LIBRARY} ${$(PROJECT.PREFIX)_LIBRARY})
.endmacro

### Generate Gradle infrastructure

.macro generate_gradle
.   directory.create ("$(topdir)/gradle/wrapper")
.#
.   output "$(topdir)/gradle/wrapper/gradle-wrapper.properties"
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\\://services.gradle.org/distributions/gradle-2.8-bin.zip
.#
.## -------------------------------------------------------------------------
.   output "$(topdir)/build.gradle"
apply plugin: 'java'
apply plugin: 'maven'
group = "org.zeromq"
version = "0.1.0-SNAPSHOT"

repositories {
    mavenLocal()
    mavenCentral()
}
sourceCompatibility = 1.7
targetCompatibility = 1.7

dependencies {
    testCompile 'junit:junit:4.12'
    testCompile 'org.hamcrest:hamcrest-all:1.3'
}
task generateJniHeaders(type: Exec, dependsOn: 'classes') {
    def classpath = sourceSets.main.output.classesDir
    def nativeIncludes = "src/native/include"
    def jniClasses = [
.       for project.class where defined (class.api) & class.jni_okay ?= 1
            '$(namespace).$(name:pascal)'$(last ()?? ""? ",")
.       endfor
    ]
    commandLine("javah", "-d", "$nativeIncludes", "-classpath", "$classpath", *jniClasses)
}
tasks.withType(Test) {
    systemProperty "java.library.path", "/usr/lib:/usr/local/lib:$projectDir"
}
task initCMake(type: Exec, dependsOn: 'generateJniHeaders') {
    commandLine "cmake", "."
}
task buildNative(type: Exec, dependsOn: 'initCMake') {
    commandLine "make"
}
jar.dependsOn buildNative
test.dependsOn buildNative
.#
.## -------------------------------------------------------------------------
.   output "$(topdir)/gradlew"
#!/usr/bin/env bash
#   Gradle start up script for Linux/UN*X
#
$(project.GENERATED_WARNING_HEADER:)
#
#   Add default JVM options here.
#   You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script
DEFAULT_JVM_OPTS=""

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`
# Use the maximum available, or set MAX_FD != -1 to use that value
MAX_FD="maximum"

warn ( ) {
    echo "$*"
}

die ( ) {
    echo
    echo "$*"
    echo
    exit 1
}

#   OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
esac

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \\(.*\\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \\"$PRG\\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \\"-Xdock:name=$APP_NAME\\" \\"-Xdock:icon=$APP_HOME/media/gradle.icns\\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\\"$arg\\""
        fi
        i=$\((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
function splitJvmOpts() {
    JVM_OPTS=("$@")
}
eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"

exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
.#
.## -------------------------------------------------------------------------
.   output "$(topdir)/gradlew.bat"
@if "%DEBUG%" == "" @echo off
@rem  Gradle startup script for Windows

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

@rem Add default JVM options here.
@rem You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windowz variants

if not "%OS%" == "Windows_NT" goto win9xME_args
if "%@eval[2+2]" == "4" goto 4NT_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*
goto execute

:4NT_args
@rem Get arguments from the 4NT Shell from JP Software
set CMD_LINE_ARGS=%$

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
.#
.## -------------------------------------------------------------------------
.   output "$(topdir)/README.md"
# $(project.prefix)-jni

JNI Binding for $(project.name:)

## Usage

Ensure you have cmake installed

```
\./grade test
```

## License

$(project->license.:)
.#
.## -------------------------------------------------------------------------
.   output "$(topdir)/settings.gradle"
rootProject.name = '$(project.prefix)-jni'
.endmacro

function resolve_jni_container (container)
    if my.container.type = "nothing"
        my.container.jni_type = "void"
        my.container.jni_ctype = "void"

    elsif my.container.type = "anything"
        my.container.jni_type = "long"
        my.container.jni_ctype = "jlong"

    elsif my.container.type = "boolean"
        my.container.jni_type = "boolean"
        my.container.jni_ctype = "jboolean"

    elsif my.container.type = "byte"
        my.container.jni_type = "byte"
        my.container.jni_ctype = "jbyte"

    elsif my.container.type = "char"
        my.container.jni_type = "char"
        my.container.jni_ctype = "jchar"

    elsif my.container.type = "integer"
        my.container.jni_type = "int"
        my.container.jni_ctype = "jint"

    elsif my.container.type = "size"
        my.container.jni_type = "long"
        my.container.jni_ctype = "jlong"

    elsif my.container.type = "number"
        if my.container.size ?= "1"
            my.container.jni_type = "byte"
            my.container.jni_ctype = "jbyte"
        elsif my.container.size = 2
            my.container.jni_type = "short"
            my.container.jni_ctype = "jshort"
        elsif my.container.size = 4
            my.container.jni_type = "int"
            my.container.jni_ctype = "jint"
        elsif my.container.size = 8
            my.container.jni_type = "long"
            my.container.jni_ctype = "jlong"
        endif

    elsif my.container.type = "real"
        my.container.jni_type = "float"
        my.container.jni_ctype = "jfloat"

    elsif my.container.type = "buffer"
        my.container.jni_type = "byte []"
        my.container.jni_ctype = "jlong"

    elsif my.container.type = "string" | my.container.type = "format"
        my.container.jni_type = "String"
        my.container.jni_ctype = "jstring"

    elsif my.container.type = "time"
        my.container.jni_type = "long"
        my.container.jni_ctype = "jlong"

    elsif my.container.type = "file_size"
        my.container.jni_type = "long"
        my.container.jni_ctype = "jlong"

    elsif defined (project.imports_$(my.container.type))
        my.container.jni_type = "$(type:pascal)"
        my.container.jni_ctype = "jlong"

    elsif count (project.class, class.name = my.container.type)
        my.container.jni_type = "long"
        my.container.jni_ctype = "jlong"

    elsif my.container.callback ?= 1
        #   For now, don't stress about how we get the address of
        #   a callback. Let's solve that later.
        my.container.jni_type = "long"
        my.container.jni_ctype = "jlong"

    elsif my.container.is_enum \
    |     my.container.type = "FILE" \
    |     my.container.type = "va_list" \
    |     my.container.type = "FILE" \
    |     my.container.type = "zmq_pollitem" \
    |     my.container.type = "socket"
        return 1
    else
        abort "Unhandled type '$(my.container.type:)' in $(class.c_name)"
    endif

    return 0            #   Seems to be OK
endfunction

function resolve_jni_method (method)
    my.method.jni_okay = 1
    my.method.jni_method_type = "void"

    if my.method.name = "clone" \
    |  my.method.name = "equals" \
    |  my.method.name = "finalize" \
    |  my.method.name = "getClass" \
    |  my.method.name = "hashCode" \
    |  my.method.name = "toString" \
    |  my.method.name = "notify" \
    |  my.method.name = "notifyAll" \
    |  my.method.name = "wait"
        my.method.jni_name = "$(Name:c)"
    else
        my.method.jni_name = "$(name:c)"
    endif

    if my.method.singleton = 1
        my.method.jni_jargs_def = ""
        my.method.jni_jargs_use = ""
        my.method.jni_cargs_def = ""
        my.method.jni_cargs_use = ""
        comma = ""
    else
        my.method.jni_jargs_def = "long self"
        my.method.jni_jargs_use = "self"
        my.method.jni_cargs_def = "jlong self"
        my.method.jni_cargs_use = "($(class.c_name)_t *) self"
        comma = ", "
    endif

    for my.method.argument where variadic ?= 0
        if resolve_jni_container (argument) = 0
            jni_jargs_def += "$(comma)$(argument.jni_type:) $(argument.name:camel)"
            jni_jargs_use += "$(comma)$(argument.name:camel)"
            jni_cargs_def += "$(comma)$(argument.jni_ctype:) $(argument.c_name)"

            if type = "format"
                jni_cargs_use += "$(comma)\"%s\", $(argument.c_name)_"
            elsif type = "string"
.#  For now, buffers must be native C and not Java byte arrays
.#            elsif type = "string" | type = "buffer"
                jni_cargs_use += "$(comma)$(argument.c_name)_"
            elsif by_reference = 1
                jni_cargs_use += "$(comma)($(argument.c_type)) &$(argument.c_name)"
            elsif callback = 1
                jni_cargs_use += "$(comma)($(argument.c_type) *) $(argument.c_name)"
            else
                jni_cargs_use += "$(comma)($(argument.c_type)) $(argument.c_name)"
            endif
            comma = ", "
        else
            my.method.jni_okay = 0
        endif
    endfor

    for my.method.return
        if resolve_jni_container (return) = 0
            my.method.jni_method_type = return.jni_type
        else
            my.method.jni_okay = 0
        endif
    endfor
endfunction

.macro generate_class_java (class)
.   directory.create ("$(topdir)/src/main/java/$(name_path)")
.   output "$(topdir)/src/main/java/$(name_path)/$(my.class.name:pascal).java"
/*
$(project.GENERATED_WARNING_HEADER:)
*/
package org.zeromq.$(project.name:c);

public class $(my.class.name:pascal) \
.   if count (my.class.constructor)
implements AutoCloseable \
.   endif
{
    static {
        try {
            System.loadLibrary ("$(project.name:c)jni");
        }
        catch (Exception e) {
            System.exit (-1);
        }
    }
    long self;

.   for constructor
    /*
    $(description:no,block)
    */
    native static long __init ($(jni_jargs_def:));
    public $(my.class.name:pascal) ($(jni_jargs_def:)) {
        /*  TODO: if __init fails, self is null...  */
        self = __init ($(jni_jargs_use:));
    }
.   endfor
.   for destructor
    /*
    $(description:no,block)
    */
    native static void __destroy (long self);
    @Override
    public void close () {
        __destroy (self);
        self = 0;
    }
.   endfor
.   for method where jni_okay
    /*
    $(description:no,block)
    */
    native static $(method.jni_method_type:) __$(c_name:) ($(jni_jargs_def:));
    public $(method.jni_method_type:) $(jni_name:) ($(jni_jargs_def:)) {
.       if ->return.type = "nothing"
        $(class.name:pascal).__$(c_name:) ($(jni_jargs_use:));
.       else
        return $(class.name:pascal).__$(c_name:) ($(jni_jargs_use:));
.       endif
    }
.   endfor
}
.endmacro

.macro generate_method_c (method)
JNIEXPORT $(->return.jni_ctype:) JNICALL
Java_$(class.c_name)__1_1$(my.method.c_name) (JNIEnv *env, jclass c\
.   if jni_cargs_def <> ""
, \
.   endif
$(jni_cargs_def:))
{
.   for argument
.       if type = "string" | type = "format"
    char *$(c_name)_ = (char *) (*env)->GetStringUTFChars (env, $(c_name), NULL);
.       elsif type = "buffer"
.#  For now, buffers must be native C and not Java byte arrays
.#    byte *$(c_name)_ = (byte *) (*env)->GetByteArrayElements (env, $(c_name), 0);
.       endif
.   endfor
.   if ->return.type = "nothing"
    $(class.c_name)_$(c_name) ($(jni_cargs_use));
.       my.return = ""
.   elsif ->return.type = "buffer"
    byte *$(c_name)_ = (byte *) $(class.c_name)_$(c_name) ($(jni_cargs_use));
.       my.return = "    return (jlong) $(c_name)_;\n"
.   elsif ->return.type = "string"
    char *$(c_name)_ = (char *) $(class.c_name)_$(c_name) ($(jni_cargs_use));
    jstring string = (*env)->NewStringUTF (env, $(c_name)_);
.       if ->return.fresh
    zstr_free (&$(c_name)_);
.       endif
.       my.return = "    return string;\n"
.   else
    $(->return.jni_ctype:) $(c_name)_ = ($(->return.jni_ctype:)) $(class.c_name)_$(c_name) ($(jni_cargs_use));
.       my.return = "    return $(c_name)_;\n"
.   endif
.   for argument
.       if type = "string" | type = "format"
    (*env)->ReleaseStringUTFChars (env, $(c_name), $(c_name)_);
.       elsif type = "buffer"
.#  For now, buffers must be native C and not Java byte arrays
.#    (*env)->ReleaseByteArrayElements (env, $(c_name), (jbyte *) $(c_name)_, 0);
.       endif
.   endfor
$(my.return)}

.endmacro

.macro generate_class_c (class)
.   directory.create ("$(topdir)/src/main/c/")
.   my.cname = "$(namespace:c)_$(my.class.name:pascal)"
.   output "$(topdir)/src/main/c/$(my.cname:).c"
/*
$(project.GENERATED_WARNING_HEADER:)
*/
#include <stdio.h>
#include <stdlib.h>
#include <jni.h>
#include "$(project.header:)"
#include "../../native/include/$(my.cname:).h"

.   for constructor
.       generate_method_c (constructor)
.   endfor
.   for destructor
.       generate_method_c (destructor)
.   endfor
.   for method where jni_okay
.       generate_method_c (method)
.   endfor
.endmacro

for project.class where defined (class.api)
    class.jni_okay = 1
    for constructor
        resolve_jni_method (constructor)
        if constructor.jni_okay = 0
            class.jni_okay = 0
        endif
    endfor
    for destructor
        resolve_jni_method (destructor)
    endfor
    for method
        resolve_jni_method (method)
    endfor
    if class.jni_okay
        generate_class_java (class)
        generate_class_c (class)
    endif
endfor

generate_cmake ()
generate_gradle ()

.endtemplate
