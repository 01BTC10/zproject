.#  ===========================================================================
.#  Generate automake files for project
.#
.#  This is a code generator built using the iMatix GSL code generation
.#  language. See https://github.com/imatix/gsl for details. This script
.#  is licensed under MIT/X11.
.#
.#  This script will generate the following files:
.#      * Makefile.am
.#      * src/Makemodule.am
.#  ===========================================================================
.output "Makefile.am"
$(project.GENERATED_WARNING_HEADER:)

ACLOCAL_AMFLAGS = -I config

AM_CFLAGS = \\
	-Werror=format-security

.if project.use_cxx
AM_CXXFLAGS = \\
    -Werror=format-security \\
    -std=c++11
.endif

AM_CPPFLAGS = \\
.for use
    \${$(use.project:c)_CFLAGS} \\
.endfor
    -I\$(srcdir)/include

.libs = ""
.for use
.   libs += " \${$(use.project:c)_LIBS}"
.endfor
project_libs =$(libs:)

SUBDIRS = $(count (class)?? "doc"? "")
DIST_SUBDIRS = $(count (class)?? "doc"? "")
lib_LTLIBRARIES =
bin_PROGRAMS =
noinst_PROGRAMS =
check_PROGRAMS =
noinst_LTLIBRARIES =
TESTS =

EXTRA_DIST = \\
.for extra
    src/$(extra.name) \\
.endfor
.for class where scope = "private"
    src/$(name:c).h \\
.endfor
    src/$(project.prefix)_classes.h \\
.if file.exists ("LICENSE")
    LICENSE \\
.endif
.if file.exists ("README.txt")
    README.txt \\
.endif
.if file.exists ("README.md")
    README.md \\
.endif
.if file.exists ("CONTRIBUTING.md")
    CONTRIBUTING.md \\
.endif
    version.sh

include \$(srcdir)/src/Makemodule.am
.if file.exists ("src/Makemodule-local.am")
include \$(srcdir)/src/Makemodule-local.am # Optional project-local hook
.endif
.directory.create ("src")
.#
.#  ===========================================================================
.output "src/Makemodule.am"
$(project.GENERATED_WARNING_HEADER:)
.libs = ""
.if count (class)
.   libs += "src/$(project.libname).la"
.endif
.if count (use)
.   libs += " ${project_libs}"
.endif
program_libs = $(libs:)

# Programs need to link the c++ runtime if everything was compiled statically.
if !ENABLE_SHARED
program_libs += -lstdc++
endif

.if count (class)
lib_LTLIBRARIES += src/$(project.libname).la
pkgconfig_DATA = src/$(project.libname).pc

.endif
.if count (class)
include_HEADERS = \\
.if file.exists ("include/$(project.prelude)")
    include/$(project.prelude) \\
.endif
.if count (class, class.c_name = project.name) = 0
    include/$(project.header:) \\
.endif
.for header where scope = "public"
    include/$(name:c).h \\
.endfor
.for class where scope = "public"
    include/$(name:c).h \\
.endfor
    include/$(project.prefix)_library.h

src_$(project.libname:c)_la_SOURCES = \\
.for class
.   if file.exists ("src/$(name:c).cc")
    src/$(name:c).cc \\
.   else
    src/$(name:c).c \\
.   endif
.endfor
.for extra
    src/$(name) \\
.endfor
    src/platform.h

src_$(project.libname:c)_la_CPPFLAGS = ${AM_CPPFLAGS}
.if project.use_cxx
src_$(project.libname:c)_la_CXXFLAGS = ${AM_CXXFLAGS}
.endif

src_$(project.libname:c)_la_LDFLAGS = \\
    -version-info @LTVER@ \\
    \$(LIBTOOL_EXTRA_LDFLAGS)

.if file.exists ("src/$(project.libname).sym")
if HAVE_LD_VERSION_SCRIPT
src_$(project.libname:c)_la_LDFLAGS += \\
    -Wl,--version-script=\$(top_srcdir)/src/$(project.libname).sym
else
src_$(project.libname:c)_la_LDFLAGS += \\
    -export-symbols \$(top_srcdir)/src/$(project.libname).sym
endif

.endif
if ON_MINGW
src_$(project.libname:c)_la_LDFLAGS += \\
    -no-undefined \\
    -avoid-version
endif

if ON_CYGWIN
src_$(project.libname:c)_la_LDFLAGS += \\
    -no-undefined \\
    -avoid-version
endif

src_$(project.libname:c)_la_LIBADD = ${project_libs}

.endif
.for project.main
if WITH_$(NAME:c)
.   if main.test ?= 1
check_PROGRAMS += src/$(main.name)
.   elsif main.scope = "public"
bin_PROGRAMS += src/$(main.name)
.   else
noinst_PROGRAMS += src/$(main.name)
.   endif
src_$(main.name:c)_CPPFLAGS = ${AM_CPPFLAGS}
src_$(main.name:c)_LDADD = ${program_libs}
.   if file.exists ("src/$(name).cc")
src_$(name:c)_SOURCES = src/$(name).cc
.   else
src_$(name:c)_SOURCES = src/$(name).c
.   endif
if WITH_SYSTEMD
.   if main.service ?= 1 | main.services ?= 1
src_$(main.name:c)_servicedir = @prefix@/lib/systemd/system
.   if ! (main.no_config ?= 1)
src_$(main.name:c)_configdir = \$(sysconfdir)/$(project.name)
.   if main.service ?= 1
src_$(main.name:c)_config_DATA = src/$(main.name).cfg
.   else
src_$(main.name:c)_config_DATA = src/$(main.name).cfg.example
.   endif
.   endif
.   if main.service ?= 1
src_$(main.name:c)_service_DATA = src/$(main.name).service
.   else
src_$(main.name:c)_service_DATA = src/$(main.name)@.service
.   endif
.   endif
.for project.main where (defined (main->extra) & extra.type ?= systemd-tmpfiles)
src_$(main.name:c)_$(main->extra.type:c)dir = $(main->extra.path)
src_$(main.name:c)_$(main->extra.type:c)_DATA = src/$(main->extra.name)
.endfor
endif #WITH_SYSTEMD

endif #WITH_$(NAME:c)
.endfor
.for bin
.   if first()

# Install data into /usr/local/bin
$(project.name:c)dir = @bindir@
$(project.name:c)_SCRIPTS = \\
.   endif
.   if !last()
    $(bin.name) \\
.   else
    $(bin.name)
.   endif
.endfor
.for service
.   if first()

$(project.name:c)_servicesdir = @prefix@/lib/systemd/system
$(project.name:c)_services_DATA = \\
.   endif
.   if !last()
    src/$(service.name).service \\
.   else
    src/$(service.name).service
.   endif
.endfor

.for class where defined (class.api)
.   if first()
# Install api files into /usr/local/share/zproject
apidir = @datadir@/zproject/$(project.name)
dist_api_DATA = \\
.   endif
.# Install files that the api includes
.   for class.include
    api/$(include.filename) \\
.   endfor
.   if !last ()
    $(class.api) \\
.   else
    $(class.api)
.   endif
.endfor

.if count (project.class)
# define custom target for all products of /src
src:
.   for project.main
\tsrc/$(main.name) \
.   endfor
\tsrc/$(project.libname).la
.endif
.for model
.   if first ()

# Produce generated code from models in the src directory
code:
.   endif
.   if defined (model.script)
\tcd $\(srcdir)/src; gsl -topdir:.. -script:$(script:) \
. for model.param
-$(param.name):$(param.value) \
. endfor
-q $(name:c).xml
.   else
\tcd $\(srcdir)/src; gsl -q $(name).xml
.   endif
.endfor

check-local: src/$(project.prefix)_selftest
\t$\(LIBTOOL) --mode=execute $\(srcdir)/src/$(project.prefix)_selftest

check-verbose: src/$(project.prefix)_selftest
\t$\(LIBTOOL) --mode=execute $\(srcdir)/src/$(project.prefix)_selftest -v

# Run the selftest binary under valgrind to check for memory leaks
memcheck: src/$(project.prefix)_selftest
\t$\(LIBTOOL) --mode=execute valgrind --tool=memcheck \\
\t\t--leak-check=full --show-reachable=yes --error-exitcode=1 \\
\t\t--suppressions=$\(srcdir)/src/.valgrind.supp \\
\t\t$\(srcdir)/src/$(project.prefix)_selftest

# Run the selftest binary under valgrind to check for performance leaks
callcheck: src/$(project.prefix)_selftest
\t$\(LIBTOOL) --mode=execute valgrind --tool=callgrind \\
\t\t$\(srcdir)/src/$(project.prefix)_selftest

# Run the selftest binary under gdb for debugging
debug: src/$(project.prefix)_selftest
\t$\(LIBTOOL) --mode=execute gdb -q \\
\t\t$\(srcdir)/src/$(project.prefix)_selftest

# Run the selftest binary with verbose switch for tracing
animate: src/$(project.prefix)_selftest
\t$\(LIBTOOL) --mode=execute $\(srcdir)/src/$(project.prefix)_selftest -v

$(project.GENERATED_WARNING_HEADER:)
.#
.#  Generate infrastructure for services
.for project.main where main.service ?= 1 | main.services ?= 1
. do_cfg = 1
.if main.service  ?= 1 & !file.exists ("src/$(main.name).cfg")
.       output "src/$(main.name).cfg"
.elsif main.services ?= 1 & !file.exists ("src/$(main.name).cfg.example")
.       output "src/$(main.name).cfg.example"
.else
.       do_cfg = 0
.endif
.if main.no_config ?= 1
. do_cfg = 0
.endif
.if do_cfg ?= 1
#   $(main.name) configuration

server
    timeout = 10000     #   Client connection timeout, msec
    background = 0      #   Run as background process
    workdir = .         #   Working directory for daemon
    verbose = 0         #   Do verbose logging of activity?
.endif
.if main.service ?= 1 & !file.exists ("src/$(main.name).service.in")
.   output "src/$(main.name).service.in"
[Unit]
Description=$(main.name) service
After=network.target

[Service]
Type=simple
Environment="prefix=@prefix@"
.if main.no_config ?= 1
ExecStart=@prefix@/bin/$(main.name)
.else
ExecStart=@prefix@/bin/$(main.name) @sysconfdir@/@PACKAGE@/$(main.name).cfg
.endif

[Install]
WantedBy=multi-user.target
.endif
.if main.services ?= 1 & !file.exists ("src/$(main.name)@.service.in")
.   output "src/$(main.name)@.service.in"
[Unit]
Description=$(main.name) service for %I
After=network.target

[Service]
Type=simple
Environment="prefix=@prefix@"
.if main.no_config ?= 1
ExecStart=@prefix@/bin/$(main.name) %i
.else
ExecStart=@prefix@/bin/$(main.name) @sysconfdir@/@PACKAGE@/%i.cfg
.endif

[Install]
WantedBy=multi-user.target
.endif
.endfor
.close
